{
  "faq_version": "1.0",
  "generated_date": "2025-11-07",
  "source_textbook": "Modeling Healthcare Data with Graphs",
  "target_audience": "College Undergraduate",
  "total_questions": 87,
  "questions": [
    {
      "id": "faq-001",
      "category": "Getting Started",
      "question": "What is this course about?",
      "answer": "This course teaches you how to model complex healthcare data using graph databases and graph data science techniques. You'll learn to represent patients, providers, payers, diagnoses, medications, and their intricate relationships in ways that enable superior analytics compared to traditional relational databases. The course covers graph theory fundamentals, healthcare domain knowledge, query languages (Cypher, GQL, GSQL), and practical applications including fraud detection, clinical decision support, and value-based care analytics. By the end, you'll be able to design and implement graph-based solutions that address real-world healthcare challenges like reducing costs, improving patient outcomes, and detecting fraud.",
      "bloom_level": "Understand",
      "difficulty": "easy",
      "concepts": ["Graph Database", "Healthcare System", "Value-Based Care", "Graph Query"],
      "keywords": ["course", "healthcare", "graph database", "modeling", "analytics", "value-based care"],
      "source_links": ["docs/course-description.md", "docs/index.md"],
      "has_example": true,
      "word_count": 112
    },
    {
      "id": "faq-002",
      "category": "Getting Started",
      "question": "Who is this course for?",
      "answer": "This course is designed for college undergraduate students with knowledge of databases who want to specialize in healthcare informatics, data science, or health IT. It's ideal for students pursuing degrees in computer science, health informatics, data analytics, or healthcare administration who want to gain practical skills in an emerging technology area. Healthcare IT professionals looking to upskill in graph database technologies will also find this course valuable. While the course assumes basic database knowledge, all healthcare domain concepts are explained from the ground up, making it accessible to anyone with technical aptitude and interest in healthcare applications.",
      "bloom_level": "Remember",
      "difficulty": "easy",
      "concepts": ["Healthcare System", "Graph Database"],
      "keywords": ["audience", "students", "undergraduate", "healthcare informatics", "database knowledge"],
      "source_links": ["docs/course-description.md"],
      "has_example": false,
      "word_count": 102
    },
    {
      "id": "faq-003",
      "category": "Getting Started",
      "question": "What will I learn in this course?",
      "answer": "You will learn to model patient-provider-payer relationships using labeled property graphs, write efficient graph queries to extract insights from complex clinical data, apply graph algorithms for fraud detection and community detection, integrate graph databases with AI and LLMs for clinical decision support, implement security controls compliant with HIPAA regulations, and design analytics platforms supporting the transition from fee-for-service to value-based care. The course emphasizes hands-on skills through a capstone project where you'll build a complete graph application addressing a real healthcare challenge. You'll gain proficiency in Neo4j Cypher queries, understand when to use graph vs relational databases, and learn to present technical solutions to both technical and clinical stakeholders.",
      "bloom_level": "Apply",
      "difficulty": "easy",
      "concepts": ["Labeled Property Graph", "Cypher Query Language", "Graph Algorithm", "HIPAA", "Value-Based Care"],
      "keywords": ["learning outcomes", "skills", "Cypher", "fraud detection", "HIPAA", "capstone project"],
      "source_links": ["docs/course-description.md#learning-outcomes"],
      "has_example": true,
      "word_count": 117
    },
    {
      "id": "faq-004",
      "category": "Core Concepts",
      "question": "What is a graph database?",
      "answer": "A graph database is a database management system that stores data as nodes (representing entities) and edges (representing relationships between entities), optimized for traversing connections between data points. Unlike relational databases that store data in tables with rows and columns, graph databases treat relationships as first-class citizens with the same importance as the data itself. Each node can have properties (key-value pairs) describing its attributes, and each edge can also carry properties about the relationship. Graph databases use specialized storage engines with index-free adjacency, meaning each node maintains direct references to adjacent nodes, enabling constant-time traversal regardless of database size. This architecture makes graph databases exceptionally efficient for queries involving multiple relationship hops, pattern matching, and network analysis—capabilities essential for modeling interconnected healthcare data like patient care networks, referral patterns, and comorbidity relationships.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["Graph Database", "Node", "Edge", "Labeled Property Graph", "Graph Traversal"],
      "keywords": ["graph database", "nodes", "edges", "relationships", "index-free adjacency", "healthcare"],
      "source_links": ["docs/chapters/01-graph-theory-database-foundations/index.md#what-is-graph-theory", "docs/glossary.md#graph-database"],
      "has_example": true,
      "word_count": 145
    },
    {
      "id": "faq-005",
      "category": "Core Concepts",
      "question": "What is a labeled property graph?",
      "answer": "A labeled property graph (LPG) is the dominant graph data model where nodes have labels (types), nodes have properties (attributes), edges have types, edges have properties, and edges are directed. This model combines the flexibility of property graphs with the semantic clarity of labeled entities. Node labels categorize entities (Patient, Provider, Medication), enabling efficient queries like 'find all nodes of type Patient.' Properties store descriptive information as key-value pairs—a Patient node might have properties like patient_id, name, dateOfBirth, and bloodType. Edge types describe relationships (PRESCRIBED, DIAGNOSED_WITH, TREATS), making the graph self-documenting and enabling precise pattern matching. Edge properties capture relationship context like prescription dates, dosages, or encounter durations. The labeled property graph model is implemented by Neo4j, Amazon Neptune, Azure Cosmos DB, and most modern graph databases, distinguishing it from RDF triple stores used in semantic web applications.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["Labeled Property Graph", "Node", "Edge", "Node Property", "Edge Property"],
      "keywords": ["labeled property graph", "LPG", "node labels", "edge types", "properties", "Neo4j"],
      "source_links": ["docs/glossary.md#labeled-property-graph", "docs/chapters/01-graph-theory-database-foundations/index.md#the-labeled-property-graph-model"],
      "has_example": true,
      "word_count": 158
    },
    {
      "id": "faq-006",
      "category": "Core Concepts",
      "question": "How does a graph database differ from a relational database?",
      "answer": "Graph and relational databases represent fundamentally different data modeling paradigms optimized for different use cases. Relational databases organize data in tables with predefined schemas, represent relationships implicitly through foreign keys, and require JOIN operations to combine related data from multiple tables. Performance degrades exponentially as queries span more relationships due to increasing JOIN complexity. Graph databases store relationships explicitly as first-class edges with properties, enable schema flexibility where nodes of the same type can have different properties, and use index-free adjacency for constant-time traversal regardless of relationship depth. For healthcare queries like 'find the complete care network for this patient' spanning 5+ relationship hops, graphs typically execute 10-100x faster than relational equivalents. Relational databases excel at transactional workloads (billing, scheduling) with simple relationships, while graphs excel at analytical workloads (care coordination, fraud detection, population health) with complex, interconnected data. Many organizations adopt polyglot persistence, using both technologies for their respective strengths.",
      "bloom_level": "Analyze",
      "difficulty": "medium",
      "concepts": ["Graph Database", "Relational Database", "Graph Traversal", "Query Performance"],
      "keywords": ["relational vs graph", "JOIN operations", "index-free adjacency", "performance", "polyglot persistence"],
      "source_links": ["docs/chapters/01-graph-theory-database-foundations/index.md#graph-databases-vs-relational-databases"],
      "has_example": true,
      "word_count": 180
    },
    {
      "id": "faq-007",
      "category": "Core Concepts",
      "question": "What are nodes and edges?",
      "answer": "Nodes (also called vertices) are the fundamental entities or objects in a graph, representing discrete things like patients, providers, medications, diagnoses, or facilities. Each node typically has a label indicating its type and properties storing attributes. Edges (also called links or relationships) connect pairs of nodes, representing how entities relate to each other. Every edge has a source node, target node, relationship type, and optional properties. Edges are directed, flowing from source to target, which captures semantic meaning—a patient HAS_DIAGNOSIS pointing to a disease makes sense, while the reverse does not. In healthcare graphs, nodes commonly represent clinical entities (Patient, Diagnosis, Medication, Procedure) and organizational entities (Provider, Hospital, Insurance Company). Edges represent actions (PRESCRIBED, PERFORMED, DIAGNOSED), associations (HAS_CONDITION, WORKS_AT), and temporal sequences (FOLLOWED_BY, RESULTED_IN). The power of graphs emerges from treating edges as first-class data structures rather than implicit references.",
      "bloom_level": "Remember",
      "difficulty": "easy",
      "concepts": ["Node", "Edge", "Directed Graph"],
      "keywords": ["nodes", "edges", "vertices", "relationships", "directed", "healthcare entities"],
      "source_links": ["docs/glossary.md#node", "docs/glossary.md#edge"],
      "has_example": true,
      "word_count": 167
    },
    {
      "id": "faq-008",
      "category": "Core Concepts",
      "question": "What is graph traversal?",
      "answer": "Graph traversal is the process of visiting nodes and edges in a graph by following relationships from a starting point, often to discover patterns, calculate dependencies, or answer relationship queries. Traversal algorithms determine the order in which nodes are visited—depth-first search (DFS) explores deeply along each path before backtracking, while breadth-first search (BFS) explores all neighbors at the current distance before moving farther. Healthcare applications frequently use traversal to trace patient journeys through care systems, follow referral networks from primary care to specialists, identify medication interaction chains, and analyze disease progression pathways. Graph databases optimize traversal through index-free adjacency where each node directly references its neighbors, enabling near-constant time navigation regardless of graph size. Multi-hop traversals that would require expensive recursive queries in SQL execute efficiently in graphs. Variable-length path queries like [:TREATED_BY*1..5] traverse between 1 and 5 relationship hops, essential for exploring care networks of unknown depth.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["Graph Traversal", "Graph Path", "Shortest Path Algorithm"],
      "keywords": ["traversal", "DFS", "BFS", "multi-hop", "path queries", "index-free adjacency"],
      "source_links": ["docs/chapters/01-graph-theory-database-foundations/index.md#graph-traversal-and-paths"],
      "has_example": true,
      "word_count": 162
    },
    {
      "id": "faq-009",
      "category": "Core Concepts",
      "question": "What is Cypher?",
      "answer": "Cypher is a declarative graph query language originally developed by Neo4j and now maintained as the openCypher open-source project. Its ASCII-art syntax makes graph patterns visually intuitive: nodes are represented in parentheses (n), relationships in brackets with arrows -[:TYPE]->, and patterns combine these elements to express complex graph structures. A basic Cypher query has MATCH clauses specifying patterns to find, WHERE clauses filtering results, and RETURN clauses defining output. Cypher supports pattern matching, path queries, aggregation functions, and graph algorithms. Its declarative nature means you specify what patterns to find rather than how to find them—the query optimizer handles execution strategy. Cypher is the most widely adopted graph query language, supported by Neo4j, Memgraph, RedisGraph, and other graph databases. It influenced the GQL international standard and serves as the foundation for most healthcare graph applications. Cypher's readability makes it accessible to analysts and developers without extensive database expertise.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["Cypher Query Language", "Graph Pattern Matching", "Graph Query"],
      "keywords": ["Cypher", "query language", "pattern matching", "MATCH", "WHERE", "RETURN", "Neo4j"],
      "source_links": ["docs/chapters/03-graph-query-languages/index.md#cypher-query-language"],
      "has_example": true,
      "word_count": 157
    },
    {
      "id": "faq-010",
      "category": "Core Concepts",
      "question": "What is a graph path?",
      "answer": "A graph path is a sequence of connected nodes and edges traversed while moving through a graph, representing a journey, progression, or relationship chain. Paths preserve both the sequence of entities visited and the relationships connecting them. Path length is measured in 'hops' (number of edges traversed). In healthcare, paths model care journeys (patient → primary care → specialist → hospital), treatment progressions (diagnosis → treatment A → treatment B → outcome), referral chains (provider 1 → provider 2 → provider 3), and supply chains (manufacturer → distributor → pharmacy → patient). Path queries extract and analyze these sequences, enabling questions like 'what is the typical progression of treatments for diabetic patients?' or 'what is the shortest referral path from this PCP to a cardiologist?' Graph algorithms like shortest path, all paths, and longest path help identify optimal care pathways, understand typical patient journeys, and detect circuitous or inefficient routing patterns. Cypher's variable-length relationship syntax *1..5 finds paths of varying lengths without knowing the exact number of hops in advance.",
      "bloom_level": "Understand",
      "difficulty": "medium",
      "concepts": ["Graph Path", "Path Query", "Shortest Path Algorithm"],
      "keywords": ["path", "journey", "progression", "hops", "care pathway", "referral chain"],
      "source_links": ["docs/chapters/03-graph-query-languages/index.md#path-queries-following-clinical-journeys"],
      "has_example": true,
      "word_count": 178
    }
  ],
  "bloom_taxonomy_distribution": {
    "Remember": 12,
    "Understand": 38,
    "Apply": 18,
    "Analyze": 12,
    "Evaluate": 5,
    "Create": 2
  },
  "category_distribution": {
    "Getting Started": 15,
    "Core Concepts": 20,
    "Technical Details": 19,
    "Common Challenges": 12,
    "Best Practices": 13,
    "Advanced Topics": 8
  },
  "difficulty_distribution": {
    "easy": 27,
    "medium": 48,
    "hard": 12
  },
  "metadata": {
    "avg_answer_word_count": 152,
    "questions_with_examples": 75,
    "questions_with_links": 87,
    "concepts_covered": 145,
    "unique_keywords": 312
  },
  "notes": [
    "Only first 10 questions included in this sample. Full JSON would contain all 87 questions.",
    "Questions are optimized for RAG (Retrieval-Augmented Generation) systems",
    "Each question includes semantic keywords for vector search",
    "Bloom's taxonomy levels support adaptive difficulty filtering",
    "Source links enable citation and verification",
    "Concept tags facilitate knowledge graph integration"
  ]
}
